#!/usr/bin/env python3
"""
Machine Learning-based Malware Detection System
Uses trained models to detect malicious Android applications
"""

import json
import pickle
import numpy as np
from pathlib import Path
from typing import Dict, List, Any, Tuple, Optional
from dataclasses import dataclass, asdict
from enum import Enum
import joblib


class MalwareClassification(Enum):
    """Malware classification levels"""
    SAFE = "SAFE"
    SUSPICIOUS = "SUSPICIOUS"
    LIKELY_MALWARE = "LIKELY_MALWARE"
    MALWARE = "MALWARE"


@dataclass
class MalwareScore:
    """Malware detection score"""
    score: float
    confidence: float
    classification: str
    features: Dict[str, float]
    risk_factors: List[str]


@dataclass
class APKFeatures:
    """Extracted features from APK"""
    # Permission features
    dangerous_permissions_count: int
    normal_permissions_count: int
    signature_permissions_count: int
    permission_entropy: float
    
    # API call features
    sensitive_api_calls: int
    network_api_calls: int
    crypto_api_calls: int
    reflection_api_calls: int
    dynamic_code_loading: int
    
    # Code features
    native_libraries_count: int
    classes_count: int
    methods_count: int
    code_size: int
    obfuscation_score: float
    
    # Certificate features
    certificate_valid: bool
    certificate_expired: bool
    self_signed: bool
    signature_mismatch: bool
    
    # Manifest features
    debuggable: bool
    backup_enabled: bool
    exported_activities_count: int
    exported_services_count: int
    exported_receivers_count: int
    
    # Network features
    network_domains_count: int
    insecure_domains_count: int
    uses_http: bool
    
    # Risk factors
    hardcoded_secrets: int
    suspicious_permissions: List[str]


class FeatureExtractor:
    """Extract features from APK for ML analysis"""
    
    # High-risk permissions
    DANGEROUS_PERMISSIONS = {
        'android.permission.READ_CONTACTS',
        'android.permission.WRITE_CONTACTS',
        'android.permission.READ_SMS',
        'android.permission.SEND_SMS',
        'android.permission.RECEIVE_SMS',
        'android.permission.CALL_PHONE',
        'android.permission.READ_PHONE_STATE',
        'android.permission.ACCESS_FINE_LOCATION',
        'android.permission.ACCESS_COARSE_LOCATION',
        'android.permission.RECORD_AUDIO',
        'android.permission.CAMERA',
        'android.permission.READ_EXTERNAL_STORAGE',
        'android.permission.WRITE_EXTERNAL_STORAGE',
    }
    
    # Suspicious API calls
    SUSPICIOUS_APIS = {
        'getDeviceId',
        'getSimSerialNumber',
        'getSubscriberId',
        'getLine1Number',
        'Runtime.exec',
        'ProcessBuilder',
        'ClassLoader.loadClass',
        'DexClassLoader',
        'getClassLoader',
    }
    
    # High-risk domains
    SUSPICIOUS_DOMAINS = {
        'bit.ly',
        'tinyurl.com',
        'goo.gl',
        'ow.ly',
        'is.gd',
    }
    
    def __init__(self, apk_path: str):
        """
        Initialize feature extractor
        
        Args:
            apk_path: Path to the APK file
        """
        self.apk_path = Path(apk_path)
        self.manifest_data = {}
        self.permissions = []
        self.domains = []
        
    def extract_features(self) -> APKFeatures:
        """
        Extract all features from APK
        
        Returns:
            APKFeatures object with extracted features
        """
        # Parse manifest and extract basic info
        self._parse_apk()
        
        # Extract permission features
        perm_features = self._extract_permission_features()
        
        # Extract API features
        api_features = self._extract_api_features()
        
        # Extract code features
        code_features = self._extract_code_features()
        
        # Extract certificate features
        cert_features = self._extract_certificate_features()
        
        # Extract manifest features
        manifest_features = self._extract_manifest_features()
        
        # Extract network features
        network_features = self._extract_network_features()
        
        # Combine all features
        features = APKFeatures(
            dangerous_permissions_count=perm_features['dangerous'],
            normal_permissions_count=perm_features['normal'],
            signature_permissions_count=perm_features['signature'],
            permission_entropy=perm_features['entropy'],
            sensitive_api_calls=api_features['sensitive'],
            network_api_calls=api_features['network'],
            crypto_api_calls=api_features['crypto'],
            reflection_api_calls=api_features['reflection'],
            dynamic_code_loading=api_features['dynamic_loading'],
            native_libraries_count=code_features['native_libs'],
            classes_count=code_features['classes'],
            methods_count=code_features['methods'],
            code_size=code_features['size'],
            obfuscation_score=code_features['obfuscation'],
            certificate_valid=cert_features['valid'],
            certificate_expired=cert_features['expired'],
            self_signed=cert_features['self_signed'],
            signature_mismatch=cert_features['mismatch'],
            debuggable=manifest_features['debuggable'],
            backup_enabled=manifest_features['backup'],
            exported_activities_count=manifest_features['exported_activities'],
            exported_services_count=manifest_features['exported_services'],
            exported_receivers_count=manifest_features['exported_receivers'],
            network_domains_count=network_features['domains'],
            insecure_domains_count=network_features['insecure'],
            uses_http=network_features['http'],
            hardcoded_secrets=self._count_hardcoded_secrets(),
            suspicious_permissions=perm_features['suspicious']
        )
        
        return features
    
    def _parse_apk(self):
        """Parse APK and extract basic information"""
        import subprocess
        
        try:
            # Use aapt to extract information
            cmd = ['aapt', 'dump', 'badging', str(self.apk_path)]
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                self._parse_aapt_output(result.stdout)
                
        except Exception as e:
            print(f"Warning: Failed to parse APK: {e}")
    
    def _parse_aapt_output(self, output: str):
        """Parse aapt output"""
        import re
        
        # Extract permissions
        self.permissions = re.findall(r'uses-permission:\s+name=[\'"](.+?)[\'"]', output)
        
        # Extract package info
        match = re.search(r'package:\s+name=[\'"](.+?)[\'"]', output)
        if match:
            self.manifest_data['package'] = match.group(1)
    
    def _extract_permission_features(self) -> Dict[str, Any]:
        """Extract permission-based features"""
        dangerous = 0
        normal = 0
        signature = 0
        suspicious = []
        
        for perm in self.permissions:
            perm_name = perm.split('.')[-1] if '.' in perm else perm
            
            if perm_name in [p.split('.')[-1] for p in self.DANGEROUS_PERMISSIONS]:
                dangerous += 1
            elif 'signature' in perm.lower():
                signature += 1
            else:
                normal += 1
            
            # Check for suspicious permission combinations
            if any(perm.startswith(p) for p in self.DANGEROUS_PERMISSIONS):
                suspicious.append(perm)
        
        # Calculate permission entropy
        entropy = self._calculate_permission_entropy()
        
        return {
            'dangerous': dangerous,
            'normal': normal,
            'signature': signature,
            'entropy': entropy,
            'suspicious': suspicious
        }
    
    def _calculate_permission_entropy(self) -> float:
        """Calculate permission entropy"""
        if not self.permissions:
            return 0.0
        
        from collections import Counter
        perm_counts = Counter(self.permissions)
        total = len(self.permissions)
        
        entropy = 0.0
        for count in perm_counts.values():
            probability = count / total
            if probability > 0:
                entropy -= probability * np.log2(probability)
        
        return entropy
    
    def _extract_api_features(self) -> Dict[str, int]:
        """Extract API usage features"""
        # This would require decompilation and code analysis
        # For now, return default values
        return {
            'sensitive': 0,
            'network': 0,
            'crypto': 0,
            'reflection': 0,
            'dynamic_loading': 0
        }
    
    def _extract_code_features(self) -> Dict[str, Any]:
        """Extract code-related features"""
        # This would require decompilation and analysis
        # For now, return default values
        return {
            'native_libs': 0,
            'classes': 0,
            'methods': 0,
            'size': 0,
            'obfuscation': 0.0
        }
    
    def _extract_certificate_features(self) -> Dict[str, bool]:
        """Extract certificate features"""
        # This would require certificate extraction and validation
        return {
            'valid': True,
            'expired': False,
            'self_signed': False,
            'mismatch': False
        }
    
    def _extract_manifest_features(self) -> Dict[str, Any]:
        """Extract manifest-related features"""
        # This would require parsing the manifest
        return {
            'debuggable': False,
            'backup': False,
            'exported_activities': 0,
            'exported_services': 0,
            'exported_receivers': 0
        }
    
    def _extract_network_features(self) -> Dict[str, Any]:
        """Extract network-related features"""
        # This would require code analysis to find domains
        return {
            'domains': 0,
            'insecure': 0,
            'http': False
        }
    
    def _count_hardcoded_secrets(self) -> int:
        """Count hardcoded secrets"""
        # This would require source code analysis
        return 0


class MalwareDetector:
    """Machine Learning-based Malware Detector"""
    
    def __init__(self, model_path: Optional[str] = None):
        """
        Initialize malware detector
        
        Args:
            model_path: Path to trained model (optional)
        """
        self.model = None
        self.scaler = None
        self.feature_names = []
        
        if model_path and Path(model_path).exists():
            self.load_model(model_path)
    
    def load_model(self, model_path: str):
        """
        Load trained model from file
        
        Args:
            model_path: Path to model file
        """
        try:
            model_data = joblib.load(model_path)
            self.model = model_data['model']
            self.scaler = model_data['scaler']
            self.feature_names = model_data['feature_names']
            print(f"Model loaded from: {model_path}")
        except Exception as e:
            print(f"Warning: Failed to load model: {e}")
            self._use_default_model()
    
    def _use_default_model(self):
        """Use default rule-based model"""
        print("Using default rule-based detection")
    
    def detect(self, apk_path: str) -> MalwareScore:
        """
        Detect if APK is malware
        
        Args:
            apk_path: Path to the APK file
            
        Returns:
            MalwareScore with detection results
        """
        # Extract features
        extractor = FeatureExtractor(apk_path)
        features = extractor.extract_features()
        
        # Convert features to array
        feature_vector = self._features_to_vector(features)
        
        # Make prediction
        if self.model is not None:
            score, confidence = self._predict_with_model(feature_vector)
        else:
            score, confidence = self._predict_with_rules(features)
        
        # Classify based on score
        classification = self._classify(score)
        
        # Extract risk factors
        risk_factors = self._extract_risk_factors(features, score)
        
        # Create feature importance map
        feature_importance = self._get_feature_importance(features)
        
        return MalwareScore(
            score=score,
            confidence=confidence,
            classification=classification,
            features=feature_importance,
            risk_factors=risk_factors
        )
    
    def _features_to_vector(self, features: APKFeatures) -> np.ndarray:
        """Convert features to numpy array for ML model"""
        return np.array([
            features.dangerous_permissions_count,
            features.normal_permissions_count,
            features.signature_permissions_count,
            features.permission_entropy,
            features.sensitive_api_calls,
            features.network_api_calls,
            features.crypto_api_calls,
            features.reflection_api_calls,
            features.dynamic_code_loading,
            features.native_libraries_count,
            features.classes_count,
            features.methods_count,
            features.code_size,
            features.obfuscation_score,
            1 if features.certificate_valid else 0,
            1 if features.certificate_expired else 0,
            1 if features.self_signed else 0,
            1 if features.signature_mismatch else 0,
            1 if features.debuggable else 0,
            1 if features.backup_enabled else 0,
            features.exported_activities_count,
            features.exported_services_count,
            features.exported_receivers_count,
            features.network_domains_count,
            features.insecure_domains_count,
            1 if features.uses_http else 0,
            features.hardcoded_secrets,
        ]).reshape(1, -1)
    
    def _predict_with_model(self, feature_vector: np.ndarray) -> Tuple[float, float]:
        """Predict using trained ML model"""
        try:
            # Scale features
            if self.scaler:
                feature_vector = self.scaler.transform(feature_vector)
            
            # Get prediction probability
            proba = self.model.predict_proba(feature_vector)
            malware_probability = proba[0][1]  # Probability of being malware
            
            # Calculate confidence
            confidence = max(proba[0])
            
            return malware_probability * 100, confidence
            
        except Exception as e:
            print(f"Model prediction failed: {e}")
            return self._predict_with_rules(feature_vector)
    
    def _predict_with_rules(self, features: APKFeatures) -> Tuple[float, float]:
        """Predict using rule-based approach"""
        score = 0.0
        
        # Permission-based scoring
        if features.dangerous_permissions_count > 5:
            score += 20
        if features.dangerous_permissions_count > 10:
            score += 20
        
        # Network-based scoring
        if features.uses_http:
            score += 15
        if features.insecure_domains_count > 0:
            score += 25
        
        # Configuration-based scoring
        if features.debuggable:
            score += 30
        if features.backup_enabled:
            score += 15
        if features.exported_activities_count > 3:
            score += 10
        
        # Certificate-based scoring
        if not features.certificate_valid or features.certificate_expired:
            score += 30
        if features.self_signed:
            score += 20
        
        # API-based scoring
        if features.sensitive_api_calls > 0:
            score += 15
        if features.dynamic_code_loading > 0:
            score += 20
        
        # Normalize score to 0-100
        score = min(100, score)
        confidence = 0.7  # Default confidence for rule-based
        
        return score, confidence
    
    def _classify(self, score: float) -> str:
        """Classify based on score"""
        if score >= 80:
            return MalwareClassification.MALWARE.value
        elif score >= 60:
            return MalwareClassification.LIKELY_MALWARE.value
        elif score >= 40:
            return MalwareClassification.SUSPICIOUS.value
        else:
            return MalwareClassification.SAFE.value
    
    def _extract_risk_factors(self, features: APKFeatures, score: float) -> List[str]:
        """Extract specific risk factors"""
        risk_factors = []
        
        if features.dangerous_permissions_count > 5:
            risk_factors.append(f"High number of dangerous permissions ({features.dangerous_permissions_count})")
        
        if features.uses_http:
            risk_factors.append("Uses insecure HTTP connections")
        
        if features.debuggable:
            risk_factors.append("Application is debuggable")
        
        if features.self_signed:
            risk_factors.append("Self-signed certificate detected")
        
        if features.hardcoded_secrets > 0:
            risk_factors.append(f"Hardcoded secrets found ({features.hardcoded_secrets})")
        
        if features.exported_activities_count > 3:
            risk_factors.append("Multiple exported activities")
        
        if features.native_libraries_count > 0:
            risk_factors.append("Contains native code")
        
        return risk_factors
    
    def _get_feature_importance(self, features: APKFeatures) -> Dict[str, float]:
        """Get feature importance for interpretation"""
        return {
            "dangerous_permissions": min(100, features.dangerous_permissions_count * 5),
            "network_security": 50 if features.uses_http else 0,
            "debug_mode": 70 if features.debuggable else 0,
            "certificate_validity": 60 if not features.certificate_valid else 0,
            "exported_components": min(100, features.exported_activities_count * 10),
            "native_code": min(100, features.native_libraries_count * 20),
        }


def main():
    """Main entry point"""
    import sys
    import argparse
    
    parser = argparse.ArgumentParser(description="ML-based Malware Detection")
    parser.add_argument("apk_path", help="Path to the APK file")
    parser.add_argument("--model", "-m", help="Path to trained model", default=None)
    parser.add_argument("--output", "-o", help="Output file path", default=None)
    parser.add_argument("--format", "-f", choices=["json", "text"], default="json", help="Output format")
    
    args = parser.parse_args()
    
    # Create detector
    detector = MalwareDetector(args.model)
    
    # Perform detection
    print(f"Analyzing: {args.apk_path}")
    result = detector.detect(args.apk_path)
    
    # Output results
    if args.format == "json":
        output = json.dumps(asdict(result), indent=2)
    else:
        output = format_text_result(result)
    
    # Write to file or stdout
    if args.output:
        with open(args.output, 'w', encoding='utf-8') as f:
            f.write(output)
        print(f"\nResults saved to: {args.output}")
    else:
        print(output)


def format_text_result(result: MalwareScore) -> str:
    """Format result as text"""
    output = [
        "ML-based Malware Detection Results",
        "=" * 40,
        f"\nMalware Score: {result.score:.2f}%",
        f"Confidence: {result.confidence:.2f}%",
        f"Classification: {result.classification}",
        "\nRisk Factors:",
    ]
    
    for factor in result.risk_factors:
        output.append(f"  • {factor}")
    
    output.append("\nFeature Importance:")
    for feature, importance in result.features.items():
        output.append(f"  • {feature}: {importance:.2f}%")
    
    return "\n".join(output)


if __name__ == "__main__":
    main()